#!/usr/bin/env python



# Program call
#   General
#     python GameServer.py -b {Path to board} -p {Path to player file} -c {Path to config file} -d {Path to output directory}
#   Exemplary
#      python GameServer.py -b ./boards/testBoard.txt -p ./players/testPlayers.txt -c ./configs/testConfigs.txt -d testRun



# Project structure
#   Separate programs:
#     Random map generator
#     Game server: Calls standardized shell scripts that in turn call player client programs. Clients can be written in any programming language (even TrumpScript - Make Python great again!) 
#     Player clients: They know the current status of board and sequence of players in this round. They communicate their move via writing N, S, W or E to standard output
#                     They are called with the following command line arguments:
#                       -p {Character} ... The character representing the called player
#                       -b {Path to current board file}
#                       -h {Path to the history file}
#   Modularity of GameServer.py:
#     The code is organized in several functions to enable work distribution
#     Functions are split over different files to reduce git conflicts (and can easily be merged later)
#   Data structures:
#     board (in Board.py) is the main data structure that holds all information of the board (similar to what a human player would know in a real board game). It is designed to be usable both for server and python-clients.



# File description
#   Initial board file
#     Plain text file containing board without players and coins (generated by hand or other program)
#     Encoding:
#       whitespace ... Empty (= Players can savely move on it)
#       ~          ... Water (= Players die if the move onto it)
#       ^          ... Mountain (= Players cannot move onto it but are allowed to walk against it without consequences)
#       $
#   Player file
#     Tab-delimited text file containing player name and client location
#     Encoding:
#       Rows     ... Different players
#       Column 1 ... Player name: a letter in lower or upper case
#       Column 2 ... Relative path to a standardized shell script that calls the player program
#   Config file
#     Tab-delimited text file containing game modus information
#     Encoding:
#       Column 1 ... Termination criterion:
#                      c ... total number of coins is specified. if last one is collected, game ends
#                      p ... number of coins a player needs to collect is specified. infinite coins are available
#       Column 2 ... Number of coins
#       Column 3 ... Waiting time (in ns) after each player's move to enable watching the game in real time (preferably with popcorn or nachos)
#   Current board file
#     Text file containing game status and matrix representation of current board including players and coins
#     Encoding:
#       TODO
#   History file
#     Text file containing all visible versions of Current board file + hidden intermediate versions to capture all single player moves
#     Encoding:
#       Same as Current board file + separation line(s)



# import python modules
import logging, time, os, sys

# import project files
from Board import *
from ParseCmd import *
from ParseConf import *
from WriteCurrentBoard import *
from Finish import *

# support for windows
is_windows = sys.platform.startswith('win')

# parse command line arguments
pathToInitialBoard, pathToPlayerFile, pathToConfigFile, pathToOutputDirectory, history, displayGUI, debugMode = parseCommandLineArguments()
if displayGUI:
    from gui.gui import *

IsGridInitialized=False
def onGridInitialized():
    """
    callback function for the GUI thread.
    It is called after the grid is initialized and
    before the TK mainloop has been started.
    (this is before something is visible) 
    """
    global IsGridInitialized
    IsGridInitialized=True

def printMatrix(matrix):
    print('\n'.join([''.join(['{:4}'.format(item) for item in row]) 
      for row in matrix]))

def clearScreen():
    if is_windows:
        _=os.system("cls")
    else:
        _=os.system("clear")
    
def main():
    ### debug options (see https://docs.python.org/2/howto/logging.html) ###
    if debugMode:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.ERROR) 
    #logging.basicConfig(filename='Debug.log', level=logging.DEBUG)

    
    ### initialization part ###
    logging.debug( "Initialization" )
    
    
    logging.debug( "Parsed file paths\n%s\n%s\n%s\n%s\nCreate History=%s" % (pathToInitialBoard, pathToPlayerFile, pathToConfigFile, pathToOutputDirectory, history) )
                 
    
    # parse config file
    configs = parseConfigFile( pathToConfigFile )
    logging.debug("Parsed config file %s\nParameters are stopCriterion:%s\tNoOfCoins:%s\tWaitingTime:%s\n" % (pathToConfigFile,configs.stopCriterion,configs.numberOfCoins,configs.waitingTime))
    
    # construct initial board by reading in board and player files
    board = Board()
    board.init( pathToInitialBoard, configs, pathToPlayerFile)
    rememberedBoards = list()
    
    # init gui
    if displayGUI:
        guiGame = GUI(onGridInitialized)
        guiGame.Map = board.matrix
        guiGame.start()
        # waiting for gui to be initialized
        print("waiting for gui to be initialized...")
        while(not IsGridInitialized):
            time.sleep(0.1)
        #draw legend
        guiGame.updateCoinsRemaining(int(configs.numberOfCoins))
    else:
        # guiGame should be None, such that we can call the update functions of the module board
        guiGame = None
        
    for i in range(len(board.players)):
        playerName = board.players[i][1]
        playerName = os.path.basename(playerName)
        if guiGame != None:
            guiGame.addPlayerToLegend(i,playerName)
                
    #add players to gui
    #draw player
    for k in board.playerInfo.keys():
        player = board.playerInfo[k]
        playerIndex = board.players.index((player.Name,player.FilePath))
        position = player.Position
        if guiGame != None:
            guiGame.addPlayerToCell(position, playerIndex)
        
    # set first coin on board and draw it to gui
    board.placeNewCoinIfNothingOnBoard(guiGame)
    
    #set outputPaths
    boardFile = os.path.join(pathToOutputDirectory, "boardCurrent.txt")
    historyFile = os.path.join(pathToOutputDirectory, "history.txt")
        
    ###  iteratitive rounds part ###
    logging.debug( "Iterative rounds" )
    while( not gameIsFinished( configs, board ) ):
        logging.debug( "nextRound")
        board.initRound()

        # determine order of players in this round
        playersSequence = [player for player, path in board.getPlayersSequence()]
        logging.debug( "Player sequence: " + ','.join(playersSequence) )
        
        # write out current board with all information (board, players, player sequence, coins per player, remaining coins, general playing configs)
        writeCurrentBoard(boardFile, board, configs)
        
        #f=raw_input()
        # forget last history
        #del rememberedBoards[:] # why should we forget the last history, ji would suggest we store every board until the game is finished in rememberedBoards
        
        for aPlayer in playersSequence:
            board.placeNewCoinIfNothingOnBoard(guiGame)
            
            logging.debug( "Player\n  " + str(aPlayer) )
            
            # remember start time of this round
            start = time.time()
            
            # ask player for her move
            move = board.requestPlayersMove( aPlayer, configs, boardFile, historyFile)
            logging.debug( "Move\n  " + str(move) )
        
            # perform player's move and consider all possible cases: moving to empty field, water, mountain, other player, coin
            board.movePlayer( aPlayer, move, guiGame)
            
            # remember updated board for writing it to history file after the round is finished
            rememberedBoards.append( board.copy() )
            
            # draw updated board
            if not displayGUI:
                clearScreen()
                writeCurrentBoardToSTDOUT(board, configs)
            
            # wait if necessary to enable watching the game in real time
            #   time.sleep would not waste cpu resources but is less accurate
            end = time.time()
            while end - start < float(configs.waitingTime) / 1000000.:
                end = time.time()
        
        
        board.distributeCoins(board.coinsOfDrownedPlayers, guiGame)
        board.coinsOfDrownedPlayers = 0                   
        
        # if a player died, place her onto the board again after all player's moves are finished and then distribute her coins
        if board.containsSuspendedPlayers():
            pass
            
        # write out history (like current board) with all remembered intermediate states of the board
        if(history == "1"):
            writeHistory(historyFile, rememberedBoards, configs) #here we write the whole board history to the file
        
        pass
        
    
    
    
    ### finishing part ###
    logging.debug( "Initialization" )
    
    # write out stuff, e.g. winner and game stats
    
    # end if key is pressed

    
if __name__ == "__main__":
    main()
